# 尚硅谷入门视频教程

## 33 第一个java程序

1. 源代码文件为.java文件，经过javac.exe会编译成字节码文件。（javac 文件名，来进行编译）
2. 字节码文件再经过java.exe会变成可执行文件（文件名为源代码中写的类名 ），并运行。（java 类名，来运行）

## 37 文档注释

文档注释是java特有的，具体格式为：

```java
/**
@auther 111
@version v1.0
*/
```

注释内容可以JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。 

javadoc解析的类必须是public类型的。

具体命令行应该怎么用javadoc，可以看https://www.bilibili.com/video/BV1Kb411W75N?p=37&spm_id_from=pageDriver

## 40 第一个java程序总结

1. 一个源文件可以声明多个class，但只能有一个类声明为public class。且声明为public的类必须与文件名同名才可以。
2. System.out.Println()中的ln是line的意思，这个方法会输出后换行。
3. 编译后会生成一个或多个字节码文件，字节码文件的文件名与源文件中的类名相同。源文件中有几个class，就会生成几个字节码文件。

## 45 java命名规范

+ 包名：多单词组成时，所有字母都小写。
+ 类名、接口名：大驼峰
+ 变量名、方法名：小驼峰
+ 常量名：所有字母大写，单词之间用_隔开。

## 47 变量的注意点

+ Java中的每个变量的作用域在一对{}内。只有在作用域内才有效。

+ 声明long型常量，必须以l或L结尾。没带l会被当成int型常量，编译会通过。

```java
	long a=12345676544322l;
	long b=12235346456436L;
```

+ 声明float常量，后面必须加f或F。
+ boolean变量的值就是true或者false，（C里面可以用1、0，java不行）。

+ byte、short、char互相做运算时，会自动转化为int。
+ 变量的强制转换和C一模一样。

+ String是引用数据类型，不是基本数据库类型！
+ String和8中基本数据类型变量可以做计算，结果为Srting类型。

## 137 java如何查看某个类的源码

按住ctrl，再点击该类即可。方法ctrl+o即可查找。

## 139 数组

### 初始化

```java
int[] a=new int[5]; //动态初始化
int[] b=new int[]{1,2,3,4,5} //静态初始化
```

### 143 java的一维数组的内存结构

![image-20220224220030817](https://s2.loli.net/2022/02/24/gRu1ANl7CimJW2z.png)

+ String存放在<font color='red'>常量池</font>。

+ static存放在静态域。

+ 方法区包括常量池和静态域。

+ 放在方法中的变量都是局部变量。数组名存放在栈中，数组内容存放在堆中！（数组名其实就是堆空间中的首地址，相当于是一个指针）。
+ 只要有new关键字，就在堆中重新开辟了空间。   

### 二维数组初始化

```java
int[][] a=new int[5][]; //动态初始化
```

列可以写可以不写！！行则必须写！！！列的长度可以每个行都不同！！！

<font color='red'>如果写列，则在堆中开辟对应的空间，不写则为null，直到后面new了之后，才会有值</font>

### 二维数组内存结构

![image-20220225202601322](https://s2.loli.net/2022/02/25/1rBLS3X2G9Me6nw.png)

array2=array1，改变array2，也会改变array1.看内存结构很轻易的可以知道这个结论。

### 操作数组的工具类

Arrays。<font color='red'>单词后面加个s，一般就是操作该单词的工具类</font>

+ Arrays

![image-20220225211128526](https://s2.loli.net/2022/02/25/g7xnlsiSe1fYzCy.png)
## 面向对象

内存解析：

+ 引用类型的变量，只可能存储两类值，null或地址值（含变量的类型）

### 197 JVM内存结构

![image-20220228100459068](https://s2.loli.net/2022/02/28/5mdWVZqsYK7ST6f.png)new出来的结构存放在堆空间中。类的对象的属性（非static)也加载在堆空间中。

方法区：存放类的加载信息，常量池，静态域。

### 匿名对象

创建对象时没有显式的指定一个变量名，即为匿名对象。匿名对象只能调用一次。

### 方法重载

方法的重载和该方法的权限修饰符，返回值类型、形参变量名、方法体都没有关系。也就是说，如果两个方法只有以上几种东西不同，会报错！

### 可变个数形参

格式：

​	数据类型 ... 变量名

```java
public void show(String ... strs){
	...
        //strs相当于一个数组，可以当数组用
        //可变个数形参必须声明在末尾！
        //最多只能声明一个可变个数形参！
}
```

这种方式相当于

```java
public void show(String[] strs){
	...
}
```

这两个方法不能构成重载，不能共存！

### ※方法参数的值传递机制！！！

Java里方法的参数传递方式只有一种：<font color='red'>值传递！</font>

+ 形参是基本数据类型，将实参基本数据类型变量的“数据值”传递给形参。
+ 形参是引用数据类型，将实参引用数据类型变量的“地址值”传递给形参。

### 封装性

封装性的体现：

+ 让类成员变量不能被随意访问和修改
+ 不对外暴露私有的方法
+ 单例模式
+ ....

通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来，就是封装性的设计思想。

### java规定的4种权限

包括了private、缺省、protected、public权限依次增大。

![image-20220303202118734](https://s2.loli.net/2022/03/03/QziVNqKljOW6MYH.png)

缺省权限，只能在一个包当中使用，出了包就不行了。

### javaBean的使用

+ 构造器的方法和该类的方法权限完全相同？对吗

### 232 this调用构造器

```java
class Person{
	private int age;
	public Person(){}
	public Person(int age){
		this(); //这样调用即可，里面也可以放参数！‘
		this.age=age;
	}
}
```

+ 在类的构造器中，可以显式的使用“this(形参列表)”，掉用本类中指定的其他构造器。不能调用自己！
+ 调用其他构造器，必须放在第一行。

### 272 方法的重写

+ 方法重写，方法名和形参列表需要完全一致。

+ 子类重写的方法的权限修饰符不能小于父类方法的权限修饰符。
+ **子类不能重写父类中private方法。**（可以理解为子类根本看不着）

+ 父类被重写的方法的返回值类型为A类，则子类的重写方法可以是**A类或A类的子类**。 

+ 子类重写的方法抛出的异常不大于父类抛出的。

### 274 super关键字

**主要就是解决子类和父类属性、方法的重名问题！！！**

-------



和this差不多，只不过super是调用父类的属性和方法的。（如果出现重名属性，默认是调用子类，加上super才能调出父类。）

+ 我们可以在子类的方法或构造器中，通过使用super.属性或super.方法的方式，显式的调用父类中声明的属性或方法。但是一般会省略。除非子类和父类有重名的属性、方法。
+ 
